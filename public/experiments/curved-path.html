<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curved Path Visualization</title>
    <style>
        body {
            margin: 0;
            background: #111;
            min-height: 100vh;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        svg {
            width: 100vw;
            height: 100vh;
        }
        .ground-path {
            fill: none;
            stroke: #D4A373;
            stroke-width: 12;
            stroke-linecap: round;
        }
        .horizon {
            stroke: #E9EDC9;
            stroke-width: 1;
            opacity: 0.5;
        }
        .path {
            fill: none;
            stroke: #D4A373;
            stroke-width: 2;
            opacity: 0.8;
        }
        .path-edge {
            fill: none;
            stroke: #D4A373;
            stroke-width: 3;
            opacity: 0.8;
        }
        .path-center {
            fill: none;
            stroke: #D4A373;
            stroke-width: 2;
            opacity: 0.5;
        }
        .path-grid {
            fill: none;
            stroke: rgba(255, 255, 255, 0.3);
            stroke-width: 1;
            opacity: 0.4;
        }
        .marker {
            fill: #E9EDC9;
            opacity: 0.8;
        }
        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .control-group {
            margin: 10px 0;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }
        input[type="range"] {
            width: 200px;
        }
        .value-display {
            font-size: 12px;
            color: #aaa;
            margin-left: 8px;
        }
        .tree {
            fill: #4A7B42;
            transform-origin: center bottom;
            transition: opacity 0.3s;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div id="controls">
        <div class="control-group">
            <label>Path Width (% of screen)<span class="value-display" id="widthValue">25%</span></label>
            <input type="range" id="pathWidth" min="10" max="50" value="25" step="1">
        </div>
        <div class="control-group">
            <label>Curve Intensity<span class="value-display" id="curveValue">0.08</span></label>
            <input type="range" id="curveIntensity" min="0" max="20" value="8" step="1">
        </div>
        <div class="control-group">
            <label>Edge Dots Count<span class="value-display" id="dotsValue">10</span></label>
            <input type="range" id="dotsCount" min="5" max="20" value="10" step="1">
        </div>
        <div class="control-group">
            <label>Dot Size<span class="value-display" id="dotSizeValue">3</span></label>
            <input type="range" id="dotSize" min="1" max="6" value="3" step="0.5">
        </div>
        <div class="control-group">
            <label>Scroll Sensitivity<span class="value-display" id="scrollValue">0.0008</span></label>
            <input type="range" id="scrollSensitivity" min="1" max="20" value="8" step="1">
        </div>
    </div>
    <svg id="scene"></svg>
    <script>
        const svg = document.getElementById('scene');
        let pathOffset = 0;
        let progress = 1;  // Start at vanishing point
        let vpX = window.innerWidth * 0.5;
        let vpY = window.innerHeight * 0.4;
        let bounceOffset = 0;

        // Add control variables
        let pathWidthPercent = 25;
        let curveIntensity = 0.08;
        let dotsCount = 10;
        let dotBaseSize = 3;
        let scrollSensitivity = 0.0008;
        let numLines = 40;
        const NUM_LATITUDE_LINES = 10;  // Number of horizontal grid lines

        // Add debug text function
        function addDebugText(x, y, text, color = 'white') {
            const debugText = document.createElementNS("http://www.w3.org/2000/svg", "text");
            debugText.setAttribute('x', x);
            debugText.setAttribute('y', y);
            debugText.setAttribute('fill', color);
            debugText.setAttribute('font-size', '12px');
            debugText.textContent = text;
            svg.appendChild(debugText);
        }

        // Update control displays
        function updateValueDisplay(id, value, suffix = '') {
            document.getElementById(id).textContent = value + suffix;
        }

        // Add event listeners for controls
        document.getElementById('pathWidth').addEventListener('input', (e) => {
            pathWidthPercent = parseInt(e.target.value);
            updateValueDisplay('widthValue', pathWidthPercent, '%');
            createScene();
        });

        document.getElementById('curveIntensity').addEventListener('input', (e) => {
            curveIntensity = parseInt(e.target.value) / 100;
            updateValueDisplay('curveValue', curveIntensity);
            createScene();
        });

        document.getElementById('dotsCount').addEventListener('input', (e) => {
            dotsCount = parseInt(e.target.value);
            updateValueDisplay('dotsValue', dotsCount);
            createScene();
        });

        document.getElementById('dotSize').addEventListener('input', (e) => {
            dotBaseSize = parseFloat(e.target.value);
            updateValueDisplay('dotSizeValue', dotBaseSize);
            createScene();
        });

        document.getElementById('scrollSensitivity').addEventListener('input', (e) => {
            scrollSensitivity = parseInt(e.target.value) / 10000;
            updateValueDisplay('scrollValue', scrollSensitivity);
        });

        function createScene() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const pathBaseWidth = width * (pathWidthPercent / 100);
            
            svg.innerHTML = '';
            
            // Add horizon line
            const horizon = document.createElementNS("http://www.w3.org/2000/svg", "line");
            horizon.setAttribute('x1', '0');
            horizon.setAttribute('y1', vpY + bounceOffset);
            horizon.setAttribute('x2', width);
            horizon.setAttribute('y2', vpY + bounceOffset);
            horizon.setAttribute('class', 'horizon');
            svg.appendChild(horizon);
            
            // Calculate the center path first
            const centerX = width * 0.5 + Math.sin(pathOffset * Math.PI * 2) * width * 0.05;
            const curveOffset = Math.sin(pathOffset * Math.PI) * width * curveIntensity;
            
            // Center control point
            const centerDistanceToVP = vpX - centerX;
            const centerControlX = centerX + centerDistanceToVP * 0.5 + curveOffset;
            const controlY = height * 0.7;
            const finalY = Math.max(vpY + bounceOffset, height * 0.2);
            const perspectiveScale = 0.3;

            // Calculate viewport overflow based on horizon position
            const horizonRatio = vpY / height;
            const viewportOverflow = 2 + (1 - horizonRatio) * 2;
            const totalWidth = width * viewportOverflow;
            const BASE_LINE_SPACING = width * 0.05;
            const numTotalLines = Math.ceil(totalWidth / BASE_LINE_SPACING);
            
            // Calculate start position to center the lines
            const startX = centerX - (totalWidth / 2);

            // Calculate how many lines should be in the path based on path width
            const pathHalfWidth = width * (pathWidthPercent / 100) / 2;
            const linesInPathHalf = Math.ceil(pathHalfWidth / BASE_LINE_SPACING);

            // Fixed edge line numbers based on path width
            const EDGE_LINE_NUMBERS = {
                left: -linesInPathHalf,
                right: linesInPathHalf
            };

            // Calculate perspective adjustment based on distance from center
            function adjustPerspective(xOffset) {
                // Calculate perspective scale based on distance from center
                const distanceRatio = Math.abs(xOffset) / (width/2);
                // Use horizonRatio to adjust perspective intensity
                const perspectiveIntensity = 0.3 + (1 - horizonRatio) * 0.3;
                return perspectiveScale * (1 + distanceRatio * perspectiveIntensity);
            }

            // Add latitude lines
            for (let i = 0; i <= NUM_LATITUDE_LINES; i++) {
                const lat_t = i / NUM_LATITUDE_LINES;
                const lat_mt = 1 - lat_t;
                const y = lat_t * lat_t * finalY + 2 * lat_t * lat_mt * controlY + lat_mt * lat_mt * height;
                
                // Create latitude line
                const latitudeLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
                latitudeLine.setAttribute('x1', centerX - pathHalfWidth * 1.5);
                latitudeLine.setAttribute('y1', y);
                latitudeLine.setAttribute('x2', centerX + pathHalfWidth * 1.5);
                latitudeLine.setAttribute('y2', y);
                latitudeLine.setAttribute('stroke', 'rgba(255, 255, 255, 0.2)');
                latitudeLine.setAttribute('stroke-width', '1');
                latitudeLine.setAttribute('stroke-dasharray', '4 4');
                svg.appendChild(latitudeLine);
                
                // Add latitude label
                addDebugText(
                    centerX + pathHalfWidth * 1.6, 
                    y, 
                    `${((1 - lat_t) * 100).toFixed(0)}%`,  // Invert percentage so 0% is at horizon
                    'rgba(255, 255, 255, 0.5)'
                );
            }

            // Store all lines with their numbers
            const lines = [];
            
            // First pass - create all lines with their numbers
            for (let i = 0; i < numTotalLines; i++) {
                const x = startX + (i * BASE_LINE_SPACING);
                const xOffset = x - centerX;
                const adjustedPerspective = adjustPerspective(xOffset);
                const controlX = centerControlX + xOffset * adjustedPerspective;

                // Skip if the line would start way outside viewport
                if (x < -width * (viewportOverflow - 1) || x > width * viewportOverflow) continue;

                // Calculate line number based on index from center
                const centerIndex = Math.floor(numTotalLines / 2);
                const lineNumber = i - centerIndex;
                
                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                const d = `
                    M ${x} ${height}
                    Q ${controlX} ${controlY},
                      ${vpX} ${finalY}
                `;
                
                // Determine if this is within the main path boundaries
                const isInMainPath = Math.abs(lineNumber) < EDGE_LINE_NUMBERS.right; // Use line numbers for path coloring
                
                path.setAttribute('d', d);
                path.setAttribute('class', isInMainPath ? 'path-center' : 'path-grid');
                svg.appendChild(path);

                // Store line info
                lines.push({
                    number: lineNumber,
                    x,
                    controlX,
                    d,
                    isInMainPath
                });
            }

            // Add line number labels at bottom
            lines.forEach(line => {
                if (line.number % 5 === 0) {  // Show every 5th line number
                    addDebugText(line.x, height - 10, line.number.toString());
                }
            });

            // Add a test dot at line -3 that moves along the path
            const dotLineNumber = -3;
            const dotX = centerX + (dotLineNumber * BASE_LINE_SPACING);
            const dotXOffset = dotX - centerX;
            const dotAdjustedPerspective = adjustPerspective(dotXOffset);
            const dotControlX = centerControlX + dotXOffset * dotAdjustedPerspective;

            // Calculate dot position along the path using progress
            const markerProgress = ((progress % 1 + 1) + 0 * (1 / dotsCount)) % 1;  // Match edge dots calculation but without offset
            const t = markerProgress;
            const mt = 1 - t;
            const movingDotX = mt * mt * dotX + 2 * mt * t * dotControlX + t * t * vpX;
            const movingDotY = mt * mt * height + 2 * mt * t * controlY + t * t * finalY;

            // Add debug info for dot
            addDebugText(10, 20, `Progress: ${progress.toFixed(2)}`);
            addDebugText(10, 40, `MarkerProgress: ${markerProgress.toFixed(2)}`);
            addDebugText(10, 60, `Line: ${dotLineNumber}`);
            addDebugText(dotX, height - 30, 'Line -3', 'red');

            // Calculate size based on position (small at vanishing point, large at bottom)
            const minSize = 2;
            const maxSize = 16;
            const dotSize = minSize + (maxSize - minSize) * mt;

            // Create and position the moving dot
            const testDot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            testDot.setAttribute('cx', movingDotX);
            testDot.setAttribute('cy', movingDotY);
            testDot.setAttribute('r', dotSize);
            testDot.setAttribute('fill', 'red');
            svg.appendChild(testDot);

            // Second pass - add edge paths and dots
            [EDGE_LINE_NUMBERS.left, EDGE_LINE_NUMBERS.right].forEach(edgeNum => {
                const edgeLine = lines.find(line => line.number === edgeNum);
                if (!edgeLine) return;

                const edgePath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                edgePath.setAttribute('d', edgeLine.d);
                edgePath.setAttribute('class', 'path-edge');
                svg.appendChild(edgePath);

                // Add dots along the edge
                for (let j = 0; j < dotsCount; j++) {
                    const markerProgress = ((progress % 1 + 1) + j * (1 / dotsCount)) % 1;
                    const marker = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    
                    const t = markerProgress;
                    const mt = 1 - t;
                    const dotX = mt * mt * edgeLine.x + 2 * mt * t * edgeLine.controlX + t * t * vpX;
                    const dotY = mt * mt * height + 2 * mt * t * controlY + t * t * finalY;
                    
                    const size = dotBaseSize * (1 - markerProgress * 0.8);
                    
                    marker.setAttribute('cx', dotX);
                    marker.setAttribute('cy', dotY);
                    marker.setAttribute('r', size);
                    marker.setAttribute('class', 'marker');
                    marker.style.opacity = (1 - markerProgress) * 0.7;
                    svg.appendChild(marker);
                }
            });
        }

        // Helper function for linear interpolation
        function lerp(start, end, t) {
            return start * (1 - t) + end * t;
        }

        // Update scroll handler to use sensitivity from controls
        window.addEventListener('wheel', (e) => {
            e.preventDefault();
            progress -= e.deltaY * scrollSensitivity;
            pathOffset -= e.deltaY * (scrollSensitivity / 2);
            bounceOffset = Math.sin(progress * Math.PI * 2) * 1.5;
            createScene();
        }, { passive: false });

        window.addEventListener('resize', createScene);
        createScene();
    </script>
</body>
</html>