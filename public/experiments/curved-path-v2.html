<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curved Path V2</title>
    <style>
        body {
            margin: 0;
            background: #111;
            min-height: 100vh;
            overflow: hidden;
        }
        svg {
            width: 100vw;
            height: 100vh;
        }
        .path {
            fill: none;
            stroke: #D4A373;
            stroke-width: 2;
            stroke-linecap: round;
        }
        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            color: white;
            font-family: sans-serif;
        }
        #controls label {
            display: block;
            margin-bottom: 5px;
        }
        #controls input {
            width: 200px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <label>Number of Control Points: <span id="pointCount">2</span></label>
        <input type="range" id="pointSlider" min="1" max="4" value="2" step="1">
    </div>
    <svg id="scene">
        <!-- We'll draw a single curved line from bottom to top -->
    </svg>

    <script>
        // Get viewport dimensions
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        // Create the path
        const svg = document.getElementById('scene');
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        
        // Create horizon line
        const horizonLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        horizonLine.setAttribute('x1', 0);
        horizonLine.setAttribute('y1', height * 0.2); // Horizon height
        horizonLine.setAttribute('x2', width);
        horizonLine.setAttribute('y2', height * 0.2);
        horizonLine.setAttribute('stroke', 'rgba(255,255,255,0.2)');
        horizonLine.setAttribute('stroke-width', '1');
        svg.appendChild(horizonLine);

        // Calculate points for a smooth curve path
        const startX = width * 0.5;    // Center at bottom
        const startY = height;         // Bottom of screen
        const endX = width * 0.5;      // Center at top
        const horizonY = height * 0.2; // Fixed horizon height

        // Initialize variables
        let controlPoints = [];
        let initialControlPoints = [];
        let scrollProgress = 0;
        const MAX_SCROLL = 1000;
        const SCROLL_SENSITIVITY = 0.5;
        let lastAddedPointTime = 0;
        const POINT_ADD_INTERVAL = 1000;
        const MAX_ACTIVE_DOTS = 3;
        const MIN_Y = horizonY;

        function generateControlPoints(count) {
            const points = [
                { x: startX, y: startY }  // Start point (yellow)
            ];
            
            // Generate control points for each curve section
            const totalHeight = startY - horizonY; // Distance from bottom to horizon
            const sectionHeight = totalHeight / (count + 1);
            
            for (let i = 0; i < count; i++) {
                const y = Math.max(startY - sectionHeight * (i + 1), MIN_Y);
                const side = i % 2 === 0 ? 1 : -1;
                const offset = 0.15; // Fixed offset for consistent path
                points.push({
                    x: startX + (width * offset * side),
                    y: y,
                    initialX: startX + (width * offset * side),
                    initialY: y
                });
            }
            
            // Add horizon point
            points.push({ 
                x: endX, 
                y: horizonY,
                initialX: endX,
                initialY: horizonY
            });
            
            return points;
        }

        function updateControlPointsPosition() {
            // Skip first and last points (yellow dots)
            for (let i = 1; i < controlPoints.length - 1; i++) {
                const point = controlPoints[i];
                
                // Calculate base progress - same for all points
                const progress = Math.min(scrollProgress / MAX_SCROLL, 1);
                
                // Each point's individual progress depends on its position from bottom
                // Points closer to bottom (higher index) will exit first
                const pointsFromBottom = (controlPoints.length - 2) - (i - 1);
                const pointProgress = progress * (1 + pointsFromBottom * 0.2);
                
                // Calculate scale that maintains curve shape until point reaches bottom
                const scale = Math.max(0, 1 - pointProgress);
                
                // Move positions while maintaining curve shape
                const xOffset = point.initialX - startX;
                const yOffset = point.initialY - startY;
                
                point.x = startX + (xOffset * scale);
                point.y = Math.max(startY + (yOffset * scale), MIN_Y);
            }
        }

        // Initialize with two control points
        controlPoints = generateControlPoints(2);
        initialControlPoints = JSON.parse(JSON.stringify(controlPoints));

        // Set path attributes and add to SVG
        path.setAttribute('class', 'path');
        svg.appendChild(path);

        // Initial render
        updatePath();
        updateGuideLines();
        updateDots();

        // Add wheel event listener
        window.addEventListener('wheel', (e) => {
            e.preventDefault();
            scrollProgress = Math.max(0, Math.min(scrollProgress + e.deltaY * SCROLL_SENSITIVITY, MAX_SCROLL));
            
            // Check if we should add a new point
            const now = Date.now();
            const activePoints = controlPoints.length - 2;
            
            if (scrollProgress > 0 && // Only when scrolling down
                now - lastAddedPointTime > POINT_ADD_INTERVAL && 
                activePoints < MAX_ACTIVE_DOTS) {
                
                // Remove the current end point
                controlPoints.pop();
                
                // Add new control point
                const lastPoint = controlPoints[controlPoints.length - 1];
                const newY = Math.max(lastPoint.y - (height * 0.2), MIN_Y);
                const prevPoint = controlPoints[controlPoints.length - 2];
                const prevSide = prevPoint.x > startX ? 1 : -1;
                const offset = 0.15;
                const x = startX + (width * offset * -prevSide);
                
                controlPoints.push({
                    x: x,
                    y: newY,
                    initialX: x,
                    initialY: newY
                });
                
                // Add new end point at horizon
                controlPoints.push({ 
                    x: endX, 
                    y: horizonY,
                    initialX: endX,
                    initialY: horizonY
                });
                
                lastAddedPointTime = now;
            }
            
            updateControlPointsPosition();
            updatePath();
            updateGuideLines();
            updateDots();
        }, { passive: false });

        // Add slider functionality
        const slider = document.getElementById('pointSlider');
        const pointCount = document.getElementById('pointCount');
        
        slider.addEventListener('input', (e) => {
            const count = parseInt(e.target.value);
            pointCount.textContent = count;
            scrollProgress = 0; // Reset scroll progress when changing points
            controlPoints = generateControlPoints(count);
            initialControlPoints = JSON.parse(JSON.stringify(controlPoints));
            updatePath();
            updateGuideLines();
            updateDots();
        });

        // Add guide lines and dots with dragging functionality
        let isDragging = false;
        let dragPoint = null;

        function createGuideLine(point1, point2) {
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute('x1', point1.x);
            line.setAttribute('y1', point1.y);
            line.setAttribute('x2', point2.x);
            line.setAttribute('y2', point2.y);
            line.setAttribute('stroke', '#666');
            line.setAttribute('stroke-width', '1');
            return line;
        }

        function updateGuideLines() {
            // Remove old guide lines
            const oldLines = svg.querySelectorAll('.guide-line');
            oldLines.forEach(line => line.remove());

            // Add new guide lines
            for (let i = 0; i < controlPoints.length - 1; i++) {
                const line = createGuideLine(controlPoints[i], controlPoints[i + 1]);
                line.classList.add('guide-line');
                svg.appendChild(line);
            }
        }

        function createDot(point, index) {
            const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            const isEndpoint = index === 0 || index === controlPoints.length - 1;
            
            dot.setAttribute('cx', point.x);
            dot.setAttribute('cy', point.y);
            dot.setAttribute('r', '6');
            dot.setAttribute('fill', isEndpoint ? 'yellow' : 'red');
            
            // Add number label next to dot (except endpoints)
            if (!isEndpoint) {
                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute('x', point.x + 15);
                text.setAttribute('y', point.y);
                text.setAttribute('fill', 'white');
                text.setAttribute('font-size', '12px');
                text.textContent = index;
                text.classList.add('dot-label');
                svg.appendChild(text);
                
                dot.style.cursor = 'move';
                dot.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    dragPoint = index;
                    dot.setAttribute('r', '8');
                });
            }
            
            return dot;
        }

        function updateDots() {
            // Remove old dots and labels
            const oldDots = svg.querySelectorAll('.control-dot');
            const oldLabels = svg.querySelectorAll('.dot-label');
            oldDots.forEach(dot => dot.remove());
            oldLabels.forEach(label => label.remove());

            // Add new dots
            controlPoints.forEach((point, i) => {
                const dot = createDot(point, i);
                dot.classList.add('control-dot');
                svg.appendChild(dot);
            });
        }

        // Add mouse event listeners to SVG
        svg.addEventListener('mousemove', (e) => {
            if (isDragging && dragPoint !== null) {
                const rect = svg.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Update control point position
                controlPoints[dragPoint].x = x;
                controlPoints[dragPoint].y = y;
                
                // Update path and visual elements
                updatePath();
                updateGuideLines();
                updateDots();
            }
        });

        svg.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                dragPoint = null;
                // Reset dot sizes
                const dots = svg.querySelectorAll('.control-dot');
                dots.forEach(dot => dot.setAttribute('r', '6'));
            }
        });

        function updatePath() {
            const points = controlPoints;
            let d = `M ${points[0].x} ${points[0].y}`;
            
            // Create a series of connected cubic Bezier curves
            for (let i = 0; i < points.length - 1; i++) {
                const current = points[i];
                const next = points[i + 1];
                const isLast = i === points.length - 2;
                
                // Calculate control points for this segment
                const dy = next.y - current.y;
                // Ensure control points never go above horizon
                const cp1y = Math.max(current.y + dy * 0.25, MIN_Y);
                const cp2y = Math.max(current.y + dy * 0.75, MIN_Y);
                
                if (isLast) {
                    // For the last segment, create a smooth curve to top point
                    const dx = next.x - current.x;
                    const cp1x = current.x;
                    const cp2x = current.x + dx * (dx > 0 ? 0.75 : 0.25);
                    d += ` C ${cp1x},${cp1y},
                           ${cp2x},${cp2y},
                           ${next.x},${Math.max(next.y, MIN_Y)}`;
                } else {
                    // For all other segments, use consistent outward curves
                    d += ` C ${current.x},${cp1y},
                           ${next.x},${cp2y},
                           ${next.x},${Math.max(next.y, MIN_Y)}`;
                }
            }
            
            path.setAttribute('d', d);
        }

        // Helper function for linear interpolation
        function lerp(start, end, t) {
            return start * (1 - t) + end * t;
        }
    </script>
</body>
</html> 