<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curved Path V2</title>
    <style>
        body {
            margin: 0;
            background: #111;
            min-height: 100vh;
            overflow: hidden;
        }
        svg {
            width: 100vw;
            height: 100vh;
        }
        .path {
            fill: none;
            stroke: #D4A373;
            stroke-width: 2;
            stroke-linecap: round;
        }
        .dot {
            fill: #D4A373;
            transition: opacity 0.2s ease-out;
        }
        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            color: #D4A373;
            font-family: sans-serif;
            min-width: 200px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }
        .control-group input {
            width: 100%;
            margin-bottom: 5px;
        }
        .value-display {
            font-size: 10px;
            color: rgba(212, 163, 115, 0.7);
        }
    </style>
</head>
<body>
    <div class="controls">
        <div class="control-group">
            <label>Wave Amplitude</label>
            <input type="range" id="amplitude" min="0" max="0.4" step="0.01" value="0.2">
            <div class="value-display">0.2</div>
        </div>
        <div class="control-group">
            <label>Look-ahead Strength</label>
            <input type="range" id="lookAhead" min="0" max="0.5" step="0.01" value="0.3">
            <div class="value-display">0.3</div>
        </div>
        <div class="control-group">
            <label>Secondary Wave Strength</label>
            <input type="range" id="secondary" min="0" max="1" step="0.01" value="0.5">
            <div class="value-display">0.5</div>
        </div>
        <div class="control-group">
            <label>Detail Wave Strength</label>
            <input type="range" id="tertiary" min="0" max="1" step="0.01" value="0.2">
            <div class="value-display">0.2</div>
        </div>
        <div class="control-group">
            <label>Scroll Sensitivity</label>
            <input type="range" id="sensitivity" min="0.5" max="4" step="0.1" value="2.0">
            <div class="value-display">2.0</div>
        </div>
    </div>

    <svg id="scene">
        <!-- We'll draw a single curved line from bottom to top -->
    </svg>

    <script>
        // Get viewport dimensions
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        // Create the path
        const svg = document.getElementById('scene');
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute('class', 'path');
        svg.appendChild(path);
        
        // Controls setup
        const controls = {
            amplitude: document.getElementById('amplitude'),
            lookAhead: document.getElementById('lookAhead'),
            secondary: document.getElementById('secondary'),
            tertiary: document.getElementById('tertiary'),
            sensitivity: document.getElementById('sensitivity')
        };

        // Update value displays
        Object.entries(controls).forEach(([key, control]) => {
            const display = control.nextElementSibling;
            control.addEventListener('input', () => {
                display.textContent = control.value;
                updatePath();
                updateDots();
            });
        });
        
        // Constants for perspective and path
        const HORIZON_Y = height * 0.2;
        const VANISHING_POINT_X = width * 0.5;
        const PATH_BASE_AMPLITUDE = width * 0.2;
        const PERSPECTIVE_FACTOR = 0.8;
        const DOT_SPACING = 0.3;
        const SCROLL_SENSITIVITY = 2.0;
        const WAVE_FREQUENCY = Math.PI * 2;  // How many waves in one cycle
        const SECONDARY_FREQUENCY = Math.PI;  // Half frequency for wider curves
        const TERTIARY_FREQUENCY = Math.PI * 4;  // Double frequency for detail
        const VIEWPORT_MARGIN = 50;  // Minimum distance from viewport edge

        // Helper function to clamp a value between min and max
        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        // Convert world coordinates to screen coordinates with perspective
        function applyPerspective(x, y, t) {
            const scale = 1 / (1 + PERSPECTIVE_FACTOR * t);
            return {
                x: VANISHING_POINT_X + (x - VANISHING_POINT_X) * scale,
                y: HORIZON_Y + (y - HORIZON_Y) * scale
            };
        }

        // Define the curve shape in world coordinates
        function worldCurveAt(t) {
            const baseY = lerp(HORIZON_Y, height, t);
            
            // Get current control values
            const PATH_BASE_AMPLITUDE = width * controls.amplitude.value;
            const LOOK_AHEAD_STRENGTH = controls.lookAhead.value;
            const SECONDARY_STRENGTH = controls.secondary.value;
            const TERTIARY_STRENGTH = controls.tertiary.value;
            
            // Calculate wave phases based on scroll position
            const mainPhase = scrollProgress * WAVE_FREQUENCY;
            const secondaryPhase = scrollProgress * SECONDARY_FREQUENCY * 0.7;
            const tertiaryPhase = scrollProgress * TERTIARY_FREQUENCY * 1.3;
            
            // Look ahead to see where the next curve is going
            const lookAheadPhase = mainPhase + WAVE_FREQUENCY * 0.25;
            const nextDirection = Math.cos(lookAheadPhase);
            
            // Amplitude increases as the wave gets closer (higher t)
            const mainAmplitude = PATH_BASE_AMPLITUDE * t;
            const secondaryAmplitude = PATH_BASE_AMPLITUDE * SECONDARY_STRENGTH * t;
            const tertiaryAmplitude = PATH_BASE_AMPLITUDE * TERTIARY_STRENGTH * t;
            
            // Add a slight bias to the exit point based on the next curve's direction
            const exitBias = -nextDirection * PATH_BASE_AMPLITUDE * LOOK_AHEAD_STRENGTH * Math.pow(t, 2);
            
            // Combine wave patterns for organic motion
            const mainWave = Math.sin(t * WAVE_FREQUENCY + mainPhase) * mainAmplitude;
            const secondaryWave = Math.sin(t * SECONDARY_FREQUENCY + secondaryPhase) * secondaryAmplitude;
            const tertiaryWave = Math.sin(t * TERTIARY_FREQUENCY + tertiaryPhase) * tertiaryAmplitude;
            
            // Calculate raw x position
            let x = VANISHING_POINT_X + mainWave + secondaryWave + tertiaryWave + exitBias;
            
            // Apply viewport boundary clamping
            // Strength increases as t approaches 1 (bottom of screen)
            const clampStrength = Math.pow(t, 3);  // Cubic curve for smooth transition
            const minX = VIEWPORT_MARGIN;
            const maxX = width - VIEWPORT_MARGIN;
            const clampedX = clamp(x, minX, maxX);
            
            // Smoothly blend between unclamped and clamped positions
            x = lerp(x, clampedX, clampStrength);
            
            return { x, y: baseY };
        }

        // Get screen coordinates for a point on the curve
        function curveAt(t) {
            const worldPos = worldCurveAt(t);
            const perspectiveT = 1 - t;
            return applyPerspective(worldPos.x, worldPos.y, perspectiveT);
        }

        // Update dots based on scroll progress
        function updateDots() {
            // Remove old dots
            const oldDots = svg.querySelectorAll('.dot');
            oldDots.forEach(dot => dot.remove());
            
            // Calculate dot positions
            const numDots = Math.ceil(1.2 / DOT_SPACING);  // Number of dots to show
            for (let i = 0; i < numDots; i++) {
                // Calculate t value for this dot, but keep the base scrollProgress continuous
                let t = ((scrollProgress % 1.2) + (i * DOT_SPACING)) % 1.2;
                
                // Only show dots within our view range
                if (t >= 0 && t <= 1.2) {
                    const pos = curveAt(Math.max(0, Math.min(1, t)));
                    const scale = 0.5 + Math.max(0, t);
                    const dotSize = 6 * scale;
                    
                    // Calculate opacity - fade out as t approaches 1
                    const opacity = t >= 0.95 ? (1 - (t - 0.95) / 0.05) : 1;
                    
                    // Create dot
                    const dotElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    dotElement.setAttribute('cx', pos.x);
                    dotElement.setAttribute('cy', pos.y);
                    dotElement.setAttribute('r', dotSize);
                    dotElement.setAttribute('class', 'dot');
                    dotElement.style.opacity = Math.max(0, opacity);
                    
                    svg.appendChild(dotElement);
                }
            }
        }

        // Update path with perspective
        function updatePath() {
            const steps = 100;
            let d = '';
            
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const pos = curveAt(t);
                d += (i === 0 ? 'M' : 'L') + ` ${pos.x},${pos.y}`;
            }
            
            path.setAttribute('d', d);
        }

        // Initialize
        let scrollProgress = 0;
        updatePath();
        updateDots();

        // Scroll handler
        window.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const delta = e.deltaY * controls.sensitivity.value * 0.001;
            scrollProgress += delta;
            
            updateDots();
            updatePath();
        }, { passive: false });

        // Helper function for linear interpolation
        function lerp(start, end, t) {
            return start * (1 - t) + end * t;
        }
    </script>
</body>
</html> 