<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curved Path V2</title>
    <style>
        body {
            margin: 0;
            background: #111;
            min-height: 100vh;
            overflow: hidden;
        }
        svg {
            width: 100vw;
            height: 100vh;
        }
        .path {
            fill: none;
            stroke: #D4A373;
            stroke-width: 2;
            stroke-linecap: round;
        }
        .path-parallel {
            fill: none;
            stroke: #D4A373;
            stroke-width: 2;
            stroke-linecap: round;
            opacity: 0.5;
        }
        .horizon-line {
            stroke: #D4A373;
            stroke-width: 1;
            opacity: 0.3;
        }
        .dot {
            fill: #D4A373;
            transition: opacity 0.2s ease-out;
        }
        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            color: #D4A373;
            font-family: sans-serif;
            min-width: 200px;
            transition: opacity 0.3s ease-out;
        }
        .controls.collapsed {
            opacity: 0;
            pointer-events: none;
        }
        .controls.collapsed .controls-content {
            opacity: 0;
        }
        .gear-icon {
            position: fixed;
            right: 20px;
            top: 20px;
            width: 24px;
            height: 24px;
            cursor: pointer;
            color: #D4A373;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border-radius: 50%;
            z-index: 1000;
        }
        .controls-content {
            margin-top: 15px;
            transition: opacity 0.2s ease-out;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }
        .control-group input {
            width: 100%;
            margin-bottom: 5px;
        }
        .value-display {
            font-size: 10px;
            color: rgba(212, 163, 115, 0.7);
        }
        .auto-scroll {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(212, 163, 115, 0.3);
        }
        .play-button {
            width: 24px;
            height: 24px;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            color: #D4A373;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .play-button:hover {
            color: #e4b383;
        }
        .auto-scroll-label {
            font-size: 12px;
        }
    </style>
</head>
<body>
    <svg class="gear-icon" viewBox="0 0 24 24" fill="currentColor">
        <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.21,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.21,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.67 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/>
    </svg>

    <div class="controls">
        <div class="controls-content">
            <div class="control-group">
                <label>Wave Amplitude</label>
                <input type="range" id="amplitude" min="0" max="0.4" step="0.01" value="0.2">
                <div class="value-display">0.2</div>
            </div>
            <div class="control-group">
                <label>Number of Curves</label>
                <input type="range" id="frequency" min="0.5" max="4" step="0.5" value="1.5">
                <div class="value-display">1.5</div>
            </div>
            <div class="control-group">
                <label>Look-ahead Strength</label>
                <input type="range" id="lookAhead" min="0" max="0.5" step="0.01" value="0.3">
                <div class="value-display">0.3</div>
            </div>
            <div class="control-group">
                <label>Secondary Wave Strength</label>
                <input type="range" id="secondary" min="0" max="1" step="0.01" value="0.5">
                <div class="value-display">0.5</div>
            </div>
            <div class="control-group">
                <label>Detail Wave Strength</label>
                <input type="range" id="tertiary" min="0" max="1" step="0.01" value="0.2">
                <div class="value-display">0.2</div>
            </div>
            <div class="control-group">
                <label>Scroll Sensitivity</label>
                <input type="range" id="sensitivity" min="0.5" max="4" step="0.1" value="2.0">
                <div class="value-display">2.0</div>
            </div>
            <div class="auto-scroll">
                <button class="play-button" title="Toggle auto-scroll">
                    <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
                        <path class="play-icon" d="M8,5.14V19.14L19,12.14L8,5.14Z"/>
                        <path class="pause-icon" d="M14,19H18V5H14M6,19H10V5H6V19Z" style="display: none;"/>
                    </svg>
                </button>
                <span class="auto-scroll-label">Auto-scroll</span>
            </div>
        </div>
    </div>

    <svg id="scene">
        <line class="horizon-line" x1="0" y1="0" x2="0" y2="0"/>
        <path class="path-parallel"/>
        <path class="path"/>
    </svg>

    <script>
        // Get viewport dimensions
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        // Create the paths
        const svg = document.getElementById('scene');
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        const pathParallel = document.createElementNS("http://www.w3.org/2000/svg", "path");
        const horizonLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        
        path.setAttribute('class', 'path');
        pathParallel.setAttribute('class', 'path-parallel');
        horizonLine.setAttribute('class', 'horizon-line');
        
        // Set horizon line coordinates
        horizonLine.setAttribute('x1', '0');
        horizonLine.setAttribute('y1', height * 0.2);
        horizonLine.setAttribute('x2', width);
        horizonLine.setAttribute('y2', height * 0.2);
        
        svg.appendChild(horizonLine);
        svg.appendChild(pathParallel);
        svg.appendChild(path);
        
        // Controls setup
        const controls = {
            amplitude: document.getElementById('amplitude'),
            frequency: document.getElementById('frequency'),
            lookAhead: document.getElementById('lookAhead'),
            secondary: document.getElementById('secondary'),
            tertiary: document.getElementById('tertiary'),
            sensitivity: document.getElementById('sensitivity')
        };

        // Calculate safe maximums based on viewport and other controls
        function updateControlLimits() {
            // Base maximum amplitude as percentage of viewport width
            const baseMaxAmplitude = Math.min(0.3, width / 2500);  // More conservative base
            
            // Calculate combined effect of all wave controls
            const totalWaveStrength = parseFloat(controls.secondary.value) + parseFloat(controls.tertiary.value);
            const combinedWaveFactor = 1 / Math.max(1, totalWaveStrength * 2);
            
            // Adjust amplitude max based on all factors
            const freqFactor = 1 / Math.max(1, controls.frequency.value * 1.5);
            const lookAheadFactor = 1 / Math.max(1, controls.lookAhead.value * 3);
            const safeAmplitude = baseMaxAmplitude * freqFactor * lookAheadFactor * combinedWaveFactor;
            
            // Update amplitude control
            controls.amplitude.max = safeAmplitude.toFixed(2);
            if (parseFloat(controls.amplitude.value) > safeAmplitude) {
                controls.amplitude.value = safeAmplitude;
                controls.amplitude.nextElementSibling.textContent = safeAmplitude.toFixed(2);
            }
            
            // Adjust frequency max based on viewport and other factors
            const baseMaxFreq = Math.min(3, width / 600);  // More conservative base
            const amplitudeFactor = 1 / Math.max(1, controls.amplitude.value * 4);
            const wavesFactor = 1 / Math.max(1, totalWaveStrength * 1.5);
            const safeFreq = baseMaxFreq * amplitudeFactor * wavesFactor;
            
            // Update frequency control
            controls.frequency.max = safeFreq.toFixed(1);
            if (parseFloat(controls.frequency.value) > safeFreq) {
                controls.frequency.value = safeFreq;
                controls.frequency.nextElementSibling.textContent = safeFreq.toFixed(1);
            }
            
            // Adjust look-ahead based on all factors
            const baseMaxLookAhead = Math.min(0.4, width / 2500);  // More conservative base
            const combinedFactor = 1 / Math.max(1, (controls.amplitude.value * controls.frequency.value * 2) + totalWaveStrength);
            const safeLookAhead = baseMaxLookAhead * combinedFactor;
            
            // Update look-ahead control
            controls.lookAhead.max = safeLookAhead.toFixed(2);
            if (parseFloat(controls.lookAhead.value) > safeLookAhead) {
                controls.lookAhead.value = safeLookAhead;
                controls.lookAhead.nextElementSibling.textContent = safeLookAhead.toFixed(2);
            }
            
            // Secondary and tertiary waves scale with all factors
            const baseMaxSecondary = Math.min(0.8, width / 2000);  // More conservative base
            const baseMaxTertiary = Math.min(0.6, width / 2000);   // Even more conservative for detail wave
            
            const mainFactor = 1 / Math.max(1, controls.amplitude.value * 3);
            const freqWaveFactor = 1 / Math.max(1, controls.frequency.value * 2);
            
            // Calculate safe values considering interdependencies
            const safeSecondary = baseMaxSecondary * mainFactor * freqWaveFactor;
            const safeTertiary = baseMaxTertiary * mainFactor * freqWaveFactor;
            
            // Update secondary and tertiary controls
            controls.secondary.max = safeSecondary.toFixed(2);
            controls.tertiary.max = safeTertiary.toFixed(2);
            
            if (parseFloat(controls.secondary.value) > safeSecondary) {
                controls.secondary.value = safeSecondary;
                controls.secondary.nextElementSibling.textContent = safeSecondary.toFixed(2);
            }
            if (parseFloat(controls.tertiary.value) > safeTertiary) {
                controls.tertiary.value = safeTertiary;
                controls.tertiary.nextElementSibling.textContent = safeTertiary.toFixed(2);
            }
        }

        // Update value displays and limits
        Object.entries(controls).forEach(([key, control]) => {
            const display = control.nextElementSibling;
            control.addEventListener('input', () => {
                // Special handling for frequency to show actual number of visual curves
                if (key === 'frequency') {
                    display.textContent = (control.value * 2).toFixed(1);
                } else {
                    display.textContent = control.value;
                }
                updateControlLimits(); // Update limits when any control changes
                updatePath();
                updateDots();
            });
        });

        // Initial display setup
        Object.entries(controls).forEach(([key, control]) => {
            const display = control.nextElementSibling;
            if (key === 'frequency') {
                display.textContent = (control.value * 2).toFixed(1);
            } else {
                display.textContent = control.value;
            }
        });

        // Update limits on window resize
        window.addEventListener('resize', () => {
            updateControlLimits();
        });

        // Initial limits setup
        updateControlLimits();
        
        // Constants for perspective and path
        const HORIZON_Y = height * 0.2;
        const VANISHING_POINT_X = width * 0.5;
        const PATH_BASE_AMPLITUDE = width * 0.2;
        const PERSPECTIVE_FACTOR = 0.8;
        const DOT_SPACING = 0.3;
        const VIEWPORT_MARGIN = 50;

        // Helper function to clamp a value between min and max
        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        // Convert world coordinates to screen coordinates with perspective
        function applyPerspective(x, y, t) {
            const scale = 1 / (1 + PERSPECTIVE_FACTOR * t);
            return {
                x: VANISHING_POINT_X + (x - VANISHING_POINT_X) * scale,
                y: HORIZON_Y + (y - HORIZON_Y) * scale
            };
        }

        // Define the curve shape in world coordinates
        function worldCurveAt(t) {
            const baseY = lerp(HORIZON_Y, height, t);
            
            // Get current control values
            const PATH_BASE_AMPLITUDE = width * controls.amplitude.value;
            const LOOK_AHEAD_STRENGTH = controls.lookAhead.value;
            const SECONDARY_STRENGTH = controls.secondary.value;
            const TERTIARY_STRENGTH = controls.tertiary.value;
            
            // Calculate frequencies based on the number of curves control
            const baseFreq = Math.PI * 2 * controls.frequency.value;
            const WAVE_FREQUENCY = baseFreq;
            const SECONDARY_FREQUENCY = baseFreq * 0.5;  // Half frequency for wider curves
            const TERTIARY_FREQUENCY = baseFreq * 2;  // Double frequency for detail
            
            // Calculate wave phases based on scroll position
            const mainPhase = scrollProgress * WAVE_FREQUENCY;
            const secondaryPhase = scrollProgress * SECONDARY_FREQUENCY * 0.7;
            const tertiaryPhase = scrollProgress * TERTIARY_FREQUENCY * 1.3;
            
            // Look ahead to see where the next curve is going
            const lookAheadPhase = mainPhase + WAVE_FREQUENCY * 0.25;
            const nextDirection = Math.cos(lookAheadPhase);
            
            // Amplitude increases as the wave gets closer (higher t)
            const mainAmplitude = PATH_BASE_AMPLITUDE * t;
            const secondaryAmplitude = PATH_BASE_AMPLITUDE * SECONDARY_STRENGTH * t;
            const tertiaryAmplitude = PATH_BASE_AMPLITUDE * TERTIARY_STRENGTH * t;
            
            // Add a slight bias to the exit point based on the next curve's direction
            const exitBias = -nextDirection * PATH_BASE_AMPLITUDE * LOOK_AHEAD_STRENGTH * Math.pow(t, 2);
            
            // Combine wave patterns for organic motion
            const mainWave = Math.sin(t * WAVE_FREQUENCY + mainPhase) * mainAmplitude;
            const secondaryWave = Math.sin(t * SECONDARY_FREQUENCY + secondaryPhase) * secondaryAmplitude;
            const tertiaryWave = Math.sin(t * TERTIARY_FREQUENCY + tertiaryPhase) * tertiaryAmplitude;
            
            // Calculate raw x position
            let x = VANISHING_POINT_X + mainWave + secondaryWave + tertiaryWave + exitBias;
            
            // Apply viewport boundary clamping with smoother transition
            const minX = VIEWPORT_MARGIN;
            const maxX = width - VIEWPORT_MARGIN;
            
            // Use smooth step function for clamping transition
            const smoothStep = (x) => x * x * (3 - 2 * x);
            const clampStrength = smoothStep(Math.pow(t, 2));
            
            // Calculate how far outside bounds we are
            const overMin = Math.max(0, minX - x);
            const overMax = Math.max(0, x - maxX);
            
            // Apply smooth clamping if outside bounds
            if (overMin > 0) {
                const smoothTransition = smoothStep(Math.min(1, overMin / (PATH_BASE_AMPLITUDE * 0.5)));
                x = lerp(x, minX, smoothTransition * clampStrength);
            } else if (overMax > 0) {
                const smoothTransition = smoothStep(Math.min(1, overMax / (PATH_BASE_AMPLITUDE * 0.5)));
                x = lerp(x, maxX, smoothTransition * clampStrength);
            }
            
            return { x, y: baseY };
        }

        // Get screen coordinates for a point on the curve
        function curveAt(t) {
            const worldPos = worldCurveAt(t);
            const perspectiveT = 1 - t;
            return applyPerspective(worldPos.x, worldPos.y, perspectiveT);
        }

        // Update dots based on scroll progress
        function updateDots() {
            // Remove old dots
            const oldDots = svg.querySelectorAll('.dot');
            oldDots.forEach(dot => dot.remove());
            
            // Calculate dot positions
            const numDots = Math.ceil(1.2 / DOT_SPACING);  // Number of dots to show
            for (let i = 0; i < numDots; i++) {
                // Calculate t value for this dot, but keep the base scrollProgress continuous
                let t = ((scrollProgress % 1.2) + (i * DOT_SPACING)) % 1.2;
                
                // Only show dots within our view range
                if (t >= 0 && t <= 1.2) {
                    const pos = curveAt(Math.max(0, Math.min(1, t)));
                    const scale = 0.5 + Math.max(0, t);
                    const dotSize = 6 * scale;
                    
                    // Calculate opacity - fade out as t approaches 1
                    const opacity = t >= 0.95 ? (1 - (t - 0.95) / 0.05) : 1;
                    
                    // Create dot
                    const dotElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    dotElement.setAttribute('cx', pos.x);
                    dotElement.setAttribute('cy', pos.y);
                    dotElement.setAttribute('r', dotSize);
                    dotElement.setAttribute('class', 'dot');
                    dotElement.style.opacity = Math.max(0, opacity);
                    
                    svg.appendChild(dotElement);
                }
            }
        }

        // Calculate normal offset point for parallel path
        function getNormalOffsetPoint(t, offset) {
            // Get two points close together to estimate slope
            const tPrev = Math.max(0, t - 0.001);
            const pPrev = curveAt(tPrev);
            const pCur = curveAt(t);
            
            // Calculate the derivative (slope)
            const dx = pCur.x - pPrev.x;
            const dy = pCur.y - pPrev.y;
            
            // Get length for normalization
            const len = Math.sqrt(dx * dx + dy * dy) || 1;
            
            // Calculate normal vector (rotate 90° CCW)
            const nx = -dy / len;
            const ny = dx / len;
            
            // Apply offset in normal direction
            return {
                x: pCur.x + nx * offset,
                y: pCur.y + ny * offset
            };
        }

        // Update path with perspective
        function updatePath() {
            const steps = 100;
            let d = '';
            let dParallel = '';
            const BASE_OFFSET = width * 0.05; // 5% of viewport width
            
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const pos = curveAt(t);
                
                // Calculate offset that grows from vanishing point
                const offsetStrength = t;
                const currentOffset = BASE_OFFSET * offsetStrength;
                
                // Get parallel point using normal offset
                const parallelPos = getNormalOffsetPoint(t, currentOffset);
                
                // Ensure both paths exactly hit the vanishing point at t=0
                if (t === 0) {
                    d += `M ${VANISHING_POINT_X},${HORIZON_Y}`;
                    dParallel += `M ${VANISHING_POINT_X},${HORIZON_Y}`;
                } else {
                    d += (i === 1 ? 'L' : ' L') + ` ${pos.x},${pos.y}`;
                    dParallel += (i === 1 ? 'L' : ' L') + ` ${parallelPos.x},${parallelPos.y}`;
                }
            }
            
            // Add final points to ensure paths reach bottom of screen
            const bottomY = height;
            const mainBottom = worldCurveAt(1);
            const parallelBottom = getNormalOffsetPoint(1, BASE_OFFSET);
            
            d += ` L ${mainBottom.x},${bottomY}`;
            dParallel += ` L ${parallelBottom.x},${bottomY}`;
            
            path.setAttribute('d', d);
            pathParallel.setAttribute('d', dParallel);
        }

        // Initialize
        let lastAngle = 0;
        let scrollProgress = 0;
        updatePath();
        updateDots();

        // Scroll handler
        window.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const delta = e.deltaY * controls.sensitivity.value * 0.001;
            scrollProgress += delta;
            
            updateDots();
            updatePath();
        }, { passive: false });

        // Helper function for linear interpolation
        function lerp(start, end, t) {
            return start * (1 - t) + end * t;
        }

        // Auto-scroll functionality
        let isAutoScrolling = false;
        let autoScrollAnimation;

        function updateAutoScroll() {
            if (isAutoScrolling) {
                const scrollStep = () => {
                    scrollProgress += 0.001 * controls.sensitivity.value;
                    updateDots();
                    updatePath();
                    autoScrollAnimation = requestAnimationFrame(scrollStep);
                };
                autoScrollAnimation = requestAnimationFrame(scrollStep);
            } else {
                cancelAnimationFrame(autoScrollAnimation);
            }
        }

        // Toggle auto-scroll
        const playButton = document.querySelector('.play-button');
        const playIcon = playButton.querySelector('.play-icon');
        const pauseIcon = playButton.querySelector('.pause-icon');

        playButton.addEventListener('click', () => {
            isAutoScrolling = !isAutoScrolling;
            playIcon.style.display = isAutoScrolling ? 'none' : 'block';
            pauseIcon.style.display = isAutoScrolling ? 'block' : 'none';
            updateAutoScroll();
        });

        // Stop auto-scroll when user manually scrolls
        window.addEventListener('wheel', () => {
            if (isAutoScrolling) {
                isAutoScrolling = false;
                playIcon.style.display = 'block';
                pauseIcon.style.display = 'none';
                updateAutoScroll();
            }
        }, { passive: false });

        // Add gear icon click handler
        document.querySelector('.gear-icon').addEventListener('click', () => {
            document.querySelector('.controls').classList.toggle('collapsed');
        });
    </script>
</body>
</html> 