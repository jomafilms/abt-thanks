<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curved Path V2</title>
    <style>
        body {
            margin: 0;
            background: #111;
            min-height: 100vh;
            overflow: hidden;
        }
        svg {
            width: 100vw;
            height: 100vh;
        }
        .path {
            fill: none;
            stroke: #D4A373;
            stroke-width: 2;
            stroke-linecap: round;
            opacity: 0.5;
        }
        .path-edge {
            fill: none;
            stroke: #D4A373;
            stroke-width: 3;
            stroke-linecap: round;
            opacity: 0.8;
        }
        .path-parallel {
            fill: none;
            stroke: #D4A373;
            stroke-width: 2;
            stroke-linecap: round;
            opacity: 0.5;
        }
        .horizon-line {
            stroke: #D4A373;
            stroke-width: 1;
            opacity: 0.3;
        }
        .dot {
            fill: #D4A373;
            transition: opacity 0.2s ease-out;
        }
        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            color: #D4A373;
            font-family: sans-serif;
            min-width: 200px;
            transition: opacity 0.3s ease-out;
        }
        .controls.collapsed {
            opacity: 0;
            pointer-events: none;
        }
        .controls.collapsed .controls-content {
            opacity: 0;
        }
        .gear-icon {
            position: fixed;
            right: 20px;
            top: 20px;
            width: 24px;
            height: 24px;
            cursor: pointer;
            color: #D4A373;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border-radius: 50%;
            z-index: 1000;
        }
        .controls-content {
            margin-top: 15px;
            transition: opacity 0.2s ease-out;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }
        .control-group input {
            width: 100%;
            margin-bottom: 5px;
        }
        .value-display {
            font-size: 10px;
            color: rgba(212, 163, 115, 0.7);
        }
        .auto-scroll {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(212, 163, 115, 0.3);
        }
        .play-button {
            width: 24px;
            height: 24px;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            color: #D4A373;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .play-button:hover {
            color: #e4b383;
        }
        .auto-scroll-label {
            font-size: 12px;
        }
        .path-grid {
            fill: none;
            stroke: rgba(255, 255, 255, 0.3);
            stroke-width: 1;
            opacity: 0.4;
        }
        .debug-text {
            fill: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <svg class="gear-icon" viewBox="0 0 24 24" fill="currentColor">
        <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.21,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.21,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.67 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/>
    </svg>

    <div class="controls">
        <div class="controls-content">
            <div class="control-group">
                <label>Wave Amplitude</label>
                <input type="range" id="amplitude" min="0" max="0.4" step="0.01" value="0.2">
                <div class="value-display">0.2</div>
            </div>
            <div class="control-group">
                <label>Number of Curves</label>
                <input type="range" id="frequency" min="0.5" max="4" step="0.5" value="1.5">
                <div class="value-display">1.5</div>
            </div>
            <div class="control-group">
                <label>Look-ahead Strength</label>
                <input type="range" id="lookAhead" min="0" max="0.5" step="0.01" value="0.3">
                <div class="value-display">0.3</div>
            </div>
            <div class="control-group">
                <label>Secondary Wave Strength</label>
                <input type="range" id="secondary" min="0" max="1" step="0.01" value="0.5">
                <div class="value-display">0.5</div>
            </div>
            <div class="control-group">
                <label>Detail Wave Strength</label>
                <input type="range" id="tertiary" min="0" max="1" step="0.01" value="0.2">
                <div class="value-display">0.2</div>
            </div>
            <div class="control-group">
                <label>Scroll Sensitivity</label>
                <input type="range" id="sensitivity" min="0.5" max="4" step="0.1" value="2.0">
                <div class="value-display">2.0</div>
            </div>
            <div class="auto-scroll">
                <button class="play-button" title="Toggle auto-scroll">
                    <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
                        <path class="play-icon" d="M8,5.14V19.14L19,12.14L8,5.14Z"/>
                        <path class="pause-icon" d="M14,19H18V5H14M6,19H10V5H6V19Z" style="display: none;"/>
                    </svg>
                </button>
                <span class="auto-scroll-label">Auto-scroll</span>
            </div>
        </div>
    </div>

    <svg id="scene">
        <line class="horizon-line" x1="0" y1="0" x2="0" y2="0"/>
        <path class="path"/>
    </svg>

    <script>
        // Get viewport dimensions
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        // Create the paths
        const svg = document.getElementById('scene');
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        const horizonLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        
        path.setAttribute('class', 'path');
        horizonLine.setAttribute('class', 'horizon-line');
        
        // Set horizon line coordinates
        horizonLine.setAttribute('x1', '0');
        horizonLine.setAttribute('y1', height * 0.4);
        horizonLine.setAttribute('x2', width);
        horizonLine.setAttribute('y2', height * 0.4);
        
        svg.appendChild(horizonLine);
        svg.appendChild(path);
        
        // Controls setup
        const controls = {
            amplitude: document.getElementById('amplitude'),
            frequency: document.getElementById('frequency'),
            lookAhead: document.getElementById('lookAhead'),
            secondary: document.getElementById('secondary'),
            tertiary: document.getElementById('tertiary'),
            sensitivity: document.getElementById('sensitivity')
        };

        // Calculate safe maximums based on viewport and other controls
        function updateControlLimits() {
            // Base maximum amplitude as percentage of viewport width
            const baseMaxAmplitude = Math.min(0.3, width / 2500);  // More conservative base
            
            // Calculate combined effect of all wave controls
            const totalWaveStrength = parseFloat(controls.secondary.value) + parseFloat(controls.tertiary.value);
            const combinedWaveFactor = 1 / Math.max(1, totalWaveStrength * 2);
            
            // Adjust amplitude max based on all factors
            const freqFactor = 1 / Math.max(1, controls.frequency.value * 1.5);
            const lookAheadFactor = 1 / Math.max(1, controls.lookAhead.value * 3);
            const safeAmplitude = baseMaxAmplitude * freqFactor * lookAheadFactor * combinedWaveFactor;
            
            // Update amplitude control
            controls.amplitude.max = safeAmplitude.toFixed(2);
            if (parseFloat(controls.amplitude.value) > safeAmplitude) {
                controls.amplitude.value = safeAmplitude;
                controls.amplitude.nextElementSibling.textContent = safeAmplitude.toFixed(2);
            }
            
            // Adjust frequency max based on viewport and other factors
            const baseMaxFreq = Math.min(3, width / 600);  // More conservative base
            const amplitudeFactor = 1 / Math.max(1, controls.amplitude.value * 4);
            const wavesFactor = 1 / Math.max(1, totalWaveStrength * 1.5);
            const safeFreq = baseMaxFreq * amplitudeFactor * wavesFactor;
            
            // Update frequency control
            controls.frequency.max = safeFreq.toFixed(1);
            if (parseFloat(controls.frequency.value) > safeFreq) {
                controls.frequency.value = safeFreq;
                controls.frequency.nextElementSibling.textContent = safeFreq.toFixed(1);
            }
            
            // Adjust look-ahead based on all factors
            const baseMaxLookAhead = Math.min(0.4, width / 2500);  // More conservative base
            const combinedFactor = 1 / Math.max(1, (controls.amplitude.value * controls.frequency.value * 2) + totalWaveStrength);
            const safeLookAhead = baseMaxLookAhead * combinedFactor;
            
            // Update look-ahead control
            controls.lookAhead.max = safeLookAhead.toFixed(2);
            if (parseFloat(controls.lookAhead.value) > safeLookAhead) {
                controls.lookAhead.value = safeLookAhead;
                controls.lookAhead.nextElementSibling.textContent = safeLookAhead.toFixed(2);
            }
            
            // Secondary and tertiary waves scale with all factors
            const baseMaxSecondary = Math.min(0.8, width / 2000);  // More conservative base
            const baseMaxTertiary = Math.min(0.6, width / 2000);   // Even more conservative for detail wave
            
            const mainFactor = 1 / Math.max(1, controls.amplitude.value * 3);
            const freqWaveFactor = 1 / Math.max(1, controls.frequency.value * 2);
            
            // Calculate safe values considering interdependencies
            const safeSecondary = baseMaxSecondary * mainFactor * freqWaveFactor;
            const safeTertiary = baseMaxTertiary * mainFactor * freqWaveFactor;
            
            // Update secondary and tertiary controls
            controls.secondary.max = safeSecondary.toFixed(2);
            controls.tertiary.max = safeTertiary.toFixed(2);
            
            if (parseFloat(controls.secondary.value) > safeSecondary) {
                controls.secondary.value = safeSecondary;
                controls.secondary.nextElementSibling.textContent = safeSecondary.toFixed(2);
            }
            if (parseFloat(controls.tertiary.value) > safeTertiary) {
                controls.tertiary.value = safeTertiary;
                controls.tertiary.nextElementSibling.textContent = safeTertiary.toFixed(2);
            }
        }

        // Update value displays and limits
        Object.entries(controls).forEach(([key, control]) => {
            const display = control.nextElementSibling;
            control.addEventListener('input', () => {
                // Special handling for frequency to show actual number of visual curves
                if (key === 'frequency') {
                    display.textContent = (control.value * 2).toFixed(1);
                } else {
                    display.textContent = control.value;
                }
                updateControlLimits(); // Update limits when any control changes
                updatePath();
                updateDots();
            });
        });

        // Initial display setup
        Object.entries(controls).forEach(([key, control]) => {
            const display = control.nextElementSibling;
            if (key === 'frequency') {
                display.textContent = (control.value * 2).toFixed(1);
            } else {
                display.textContent = control.value;
            }
        });

        // Update limits on window resize
        window.addEventListener('resize', () => {
            updateControlLimits();
        });

        // Initial limits setup
        updateControlLimits();
        
        // Constants for perspective and path
        const HORIZON_Y = height * 0.4;
        const VANISHING_POINT_X = width * 0.5;
        const PATH_BASE_AMPLITUDE = width * 0.2;
        const PERSPECTIVE_FACTOR = 0.8;
        const DOT_SPACING = 0.3;
        const VIEWPORT_MARGIN = 50;
        const BASE_LINE_SPACING = width * 0.05;  // 5% of viewport width
        const horizonRatio = HORIZON_Y / height;
        const viewportOverflow = 2 + (1 - horizonRatio) * 2;
        const totalWidth = width * viewportOverflow;
        const NUM_GRID_LINES = Math.ceil((totalWidth / BASE_LINE_SPACING) / 2);  // Divide by 2 since we're counting from center
        const NUM_LATITUDE_LINES = 10;
        let bounceOffset = 0;

        // Path width control
        const pathWidthPercent = 25;  // 25% of viewport width
        const pathHalfWidth = width * (pathWidthPercent / 100) / 2;
        const linesInPathHalf = Math.ceil(pathHalfWidth / BASE_LINE_SPACING);
        const EDGE_LINE_NUMBERS = {
            left: -linesInPathHalf,
            right: linesInPathHalf
        };

        // Configuration loading
        let staticConfig = null;
        let markersWithNames = [];

        // Function to load and merge configuration
        async function loadConfiguration() {
            try {
                // Load static configuration
                const staticResponse = await fetch('static.json');
                staticConfig = await staticResponse.json();

                // Load names
                const namesResponse = await fetch('names.json');
                const namesData = await namesResponse.json();

                // Assign names to available markers
                markersWithNames = staticConfig.markers.map(marker => {
                    if (marker.canReceiveName && namesData.names.length > 0) {
                        const nextName = namesData.names.shift();
                        return { ...marker, name: nextName.name };
                    }
                    return marker;
                });

                // Initial scene creation
                updatePath();
            } catch (error) {
                console.error('Error loading configuration:', error);
            }
        }

        // Helper function for linear interpolation
        function lerp(start, end, t) {
            return start * (1 - t) + end * t;
        }

        // Helper function to update horizon line position
        function updateHorizonLine() {
            horizonLine.setAttribute('y1', HORIZON_Y + bounceOffset);
            horizonLine.setAttribute('y2', HORIZON_Y + bounceOffset);
        }

        // Update scroll handler to include bounce
        window.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const delta = e.deltaY * controls.sensitivity.value * 0.001;
            scrollProgress += delta;
            
            // Update bounce offset based on scroll progress
            bounceOffset = Math.sin(scrollProgress * Math.PI * 2) * 1.5;
            
            updateHorizonLine();
            updatePath();
            updateDots();
        }, { passive: false });

        // Update auto-scroll to include bounce
        function updateAutoScroll() {
            if (isAutoScrolling) {
                const scrollStep = () => {
                    scrollProgress += 0.001 * controls.sensitivity.value;
                    bounceOffset = Math.sin(scrollProgress * Math.PI * 2) * 1.5;
                    updateHorizonLine();
                    updateDots();
                    updatePath();
                    autoScrollAnimation = requestAnimationFrame(scrollStep);
                };
                autoScrollAnimation = requestAnimationFrame(scrollStep);
            } else {
                cancelAnimationFrame(autoScrollAnimation);
            }
        }

        // Modify applyPerspective to use bouncing vanishing point
        function applyPerspective(x, y, t) {
            const scale = 1 / (1 + PERSPECTIVE_FACTOR * t);
            return {
                x: VANISHING_POINT_X + (x - VANISHING_POINT_X) * scale,
                y: (HORIZON_Y + bounceOffset) + (y - (HORIZON_Y + bounceOffset)) * scale
            };
        }

        // Helper function to clamp a value between min and max
        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        // Define the curve shape in world coordinates
        function worldCurveAt(t) {
            // Extend the base Y position to go 20% beyond the bottom of the screen
            const extendedHeight = height * 1.2;
            const baseY = lerp(HORIZON_Y, extendedHeight, t);
            
            // Rest of the function remains the same
            const PATH_BASE_AMPLITUDE = width * controls.amplitude.value;
            const LOOK_AHEAD_STRENGTH = controls.lookAhead.value;
            const SECONDARY_STRENGTH = controls.secondary.value;
            const TERTIARY_STRENGTH = controls.tertiary.value;
            
            // Calculate frequencies based on the number of curves control
            const baseFreq = Math.PI * 2 * controls.frequency.value;
            const WAVE_FREQUENCY = baseFreq;
            const SECONDARY_FREQUENCY = baseFreq * 0.5;
            const TERTIARY_FREQUENCY = baseFreq * 2;
            
            // Calculate wave phases based on scroll position
            const mainPhase = scrollProgress * WAVE_FREQUENCY;
            const secondaryPhase = scrollProgress * SECONDARY_FREQUENCY * 0.7;
            const tertiaryPhase = scrollProgress * TERTIARY_FREQUENCY * 1.3;
            
            const lookAheadPhase = mainPhase + WAVE_FREQUENCY * 0.25;
            const nextDirection = Math.cos(lookAheadPhase);
            
            const mainAmplitude = PATH_BASE_AMPLITUDE * t;
            const secondaryAmplitude = PATH_BASE_AMPLITUDE * SECONDARY_STRENGTH * t;
            const tertiaryAmplitude = PATH_BASE_AMPLITUDE * TERTIARY_STRENGTH * t;
            
            const exitBias = -nextDirection * PATH_BASE_AMPLITUDE * LOOK_AHEAD_STRENGTH * Math.pow(t, 2);
            
            const mainWave = Math.sin(t * WAVE_FREQUENCY + mainPhase) * mainAmplitude;
            const secondaryWave = Math.sin(t * SECONDARY_FREQUENCY + secondaryPhase) * secondaryAmplitude;
            const tertiaryWave = Math.sin(t * TERTIARY_FREQUENCY + tertiaryPhase) * tertiaryAmplitude;
            
            let x = VANISHING_POINT_X + mainWave + secondaryWave + tertiaryWave + exitBias;
            
            const minX = VIEWPORT_MARGIN;
            const maxX = width - VIEWPORT_MARGIN;
            
            const smoothStep = (x) => x * x * (3 - 2 * x);
            const clampStrength = smoothStep(Math.pow(t, 2));
            
            const overMin = Math.max(0, minX - x);
            const overMax = Math.max(0, x - maxX);
            
            if (overMin > 0) {
                const smoothTransition = smoothStep(Math.min(1, overMin / (PATH_BASE_AMPLITUDE * 0.5)));
                x = lerp(x, minX, smoothTransition * clampStrength);
            } else if (overMax > 0) {
                const smoothTransition = smoothStep(Math.min(1, overMax / (PATH_BASE_AMPLITUDE * 0.5)));
                x = lerp(x, maxX, smoothTransition * clampStrength);
            }
            
            return { x, y: baseY };
        }

        // Get screen coordinates for a point on the curve
        function curveAt(t) {
            const worldPos = worldCurveAt(t);
            const perspectiveT = 1 - t;
            return applyPerspective(worldPos.x, worldPos.y, perspectiveT);
        }

        // Update dots based on scroll progress
        function updateDots() {
            // Remove old dots
            const oldDots = svg.querySelectorAll('.dot');
            oldDots.forEach(dot => dot.remove());
            
            // Calculate dot positions
            const numDots = Math.ceil(1.2 / DOT_SPACING);  // Number of dots to show
            for (let i = 0; i < numDots; i++) {
                // Calculate t value for this dot, but keep the base scrollProgress continuous
                let t = ((scrollProgress % 1.2) + (i * DOT_SPACING)) % 1.2;
                
                // Only show dots within our view range
                if (t >= 0 && t <= 1.2) {
                    const pos = curveAt(Math.max(0, Math.min(1, t)));
                    const scale = 0.5 + Math.max(0, t);
                    const dotSize = 6 * scale;
                    
                    // Calculate opacity - fade out as t approaches 1
                    const opacity = t >= 0.95 ? (1 - (t - 0.95) / 0.05) : 1;
                    
                    // Create dot
                    const dotElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    dotElement.setAttribute('cx', pos.x);
                    dotElement.setAttribute('cy', pos.y);
                    dotElement.setAttribute('r', dotSize);
                    dotElement.setAttribute('class', 'dot');
                    dotElement.style.opacity = Math.max(0, opacity);
                    
                    svg.appendChild(dotElement);
                }
            }
        }

        // Helper function to add debug text
        function addDebugText(x, y, text) {
            const debugText = document.createElementNS("http://www.w3.org/2000/svg", "text");
            debugText.setAttribute('x', x);
            debugText.setAttribute('y', y);
            debugText.setAttribute('class', 'debug-text');
            debugText.textContent = text;
            svg.appendChild(debugText);
        }

        // Update path with perspective
        function updatePath() {
            const steps = 100;
            let d = '';
            
            // Clear existing paths and grid lines
            svg.innerHTML = '';
            svg.appendChild(horizonLine);
            
            // Add latitude lines
            for (let i = 0; i <= NUM_LATITUDE_LINES; i++) {
                const t = i / NUM_LATITUDE_LINES;
                const mt = 1 - t;
                const y = lerp(HORIZON_Y, height, t * t); // Quadratic interpolation for perspective
                
                const latLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
                latLine.setAttribute('x1', VANISHING_POINT_X - width * 0.4);
                latLine.setAttribute('y1', y);
                latLine.setAttribute('x2', VANISHING_POINT_X + width * 0.4);
                latLine.setAttribute('y2', y);
                latLine.setAttribute('class', 'path-grid');
                latLine.setAttribute('stroke-dasharray', '4 4');
                svg.appendChild(latLine);
                
                // Add percentage label
                addDebugText(
                    VANISHING_POINT_X + width * 0.42,
                    y,
                    `${(mt * 100).toFixed(0)}%`
                );
            }
            
            // Add vertical grid lines and store line info
            const lines = [];
            const gridSpacing = BASE_LINE_SPACING;
            for (let i = -NUM_GRID_LINES; i <= NUM_GRID_LINES; i++) {
                if (i === 0) continue; // Skip center line as it's our main path
                
                const xOffset = i * gridSpacing;
                const gridPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                let gridD = `M ${VANISHING_POINT_X + xOffset * 0.2} ${HORIZON_Y}`; // Start at horizon with compressed spacing
                
                for (let j = 0; j <= steps; j++) {
                    const t = j / steps;
                    const worldPos = worldCurveAt(t);
                    // Scale offset more at bottom, less at top
                    worldPos.x += xOffset * t; // Adjust x-offset based on perspective
                    const pos = applyPerspective(worldPos.x, worldPos.y, 1 - t);
                    gridD += ` ${j === 0 ? 'M' : 'L'} ${pos.x},${pos.y}`;
                }
                
                // Determine if this is within the main path boundaries
                const isInMainPath = Math.abs(i) < EDGE_LINE_NUMBERS.right;
                
                gridPath.setAttribute('d', gridD);
                gridPath.setAttribute('class', isInMainPath ? 'path-grid' : 'path-grid');
                svg.appendChild(gridPath);
                
                // Store line info
                lines.push({
                    number: i,
                    xOffset,
                    d: gridD,
                    isInMainPath
                });
                
                // Add line number at bottom
                if (i % 5 === 0) {
                    addDebugText(VANISHING_POINT_X + xOffset, height - 10, i.toString());
                }
            }
            
            // Store points for main path
            const mainPoints = [];
            
            // Generate points for main path
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const pos = curveAt(t);
                mainPoints.push(pos);
            }
            
            // Build main path
            d = `M ${VANISHING_POINT_X},${HORIZON_Y}`;
            mainPoints.forEach((pos, i) => {
                if (i > 0) d += ` L ${pos.x},${pos.y}`;
            });
            
            // Create and append center path
            const mainPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
            mainPath.setAttribute('class', 'path');
            mainPath.setAttribute('d', d);
            svg.appendChild(mainPath);
            
            // Add edge paths
            [EDGE_LINE_NUMBERS.left, EDGE_LINE_NUMBERS.right].forEach(edgeNum => {
                const edgeLine = lines.find(line => line.number === edgeNum);
                if (!edgeLine) return;

                const edgePath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                edgePath.setAttribute('d', edgeLine.d);
                edgePath.setAttribute('class', 'path-edge');
                svg.appendChild(edgePath);
            });
            
            // Add markers if configuration is loaded
            if (staticConfig && markersWithNames) {
                markersWithNames.forEach(marker => {
                    const markerLine = lines.find(line => line.number === marker.line);
                    if (!markerLine) return;

                    // Calculate marker position along the path using progress
                    const t = marker.startProgress;
                    const worldPos = worldCurveAt(t);
                    worldPos.x += markerLine.xOffset * t; // Apply line offset
                    const pos = applyPerspective(worldPos.x, worldPos.y, 1 - t);

                    // Calculate size based on position and configuration
                    const config = marker.type === 'circle' ? staticConfig.config.circles : staticConfig.config.rectangles;
                    const minSize = config.minSize || 2;
                    const maxSize = config.maxSize || 16;
                    const baseSize = minSize + (maxSize - minSize) * (1 - t);

                    if (marker.type === 'circle') {
                        // Create and position the circle
                        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                        circle.setAttribute('cx', pos.x);
                        circle.setAttribute('cy', pos.y);
                        circle.setAttribute('r', baseSize);
                        circle.setAttribute('fill', marker.color);
                        svg.appendChild(circle);
                    } else if (marker.type === 'rectangle' && marker.name) {
                        // Create and position the rectangle
                        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        const rectWidth = baseSize * config.defaultWidth;
                        const rectHeight = baseSize * config.defaultHeight;
                        rect.setAttribute('x', pos.x - rectWidth/2);
                        rect.setAttribute('y', pos.y - rectHeight/2);
                        rect.setAttribute('width', rectWidth);
                        rect.setAttribute('height', rectHeight);
                        rect.setAttribute('fill', marker.color);
                        rect.setAttribute('rx', rectHeight * config.cornerRadius);
                        svg.appendChild(rect);

                        // Add name label inside rectangle
                        const nameLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        nameLabel.setAttribute('x', pos.x);
                        nameLabel.setAttribute('y', pos.y + baseSize * 0.3);
                        nameLabel.setAttribute('fill', '#000');
                        nameLabel.setAttribute('font-size', `${baseSize * config.fontScale}px`);
                        nameLabel.setAttribute('text-anchor', 'middle');
                        nameLabel.setAttribute('dominant-baseline', 'middle');
                        nameLabel.textContent = marker.name;
                        svg.appendChild(nameLabel);
                    }
                });
            }
            
            // Update dots last so they're on top
            updateDots();
        }

        // Initialize
        let lastAngle = 0;
        let scrollProgress = 0;
        loadConfiguration();  // Load config first, which will then call updatePath()
        updateDots();

        // Auto-scroll functionality
        let isAutoScrolling = false;
        let autoScrollAnimation;

        // Toggle auto-scroll
        const playButton = document.querySelector('.play-button');
        const playIcon = playButton.querySelector('.play-icon');
        const pauseIcon = playButton.querySelector('.pause-icon');

        playButton.addEventListener('click', () => {
            isAutoScrolling = !isAutoScrolling;
            playIcon.style.display = isAutoScrolling ? 'none' : 'block';
            pauseIcon.style.display = isAutoScrolling ? 'block' : 'none';
            updateAutoScroll();
        });

        // Stop auto-scroll when user manually scrolls
        window.addEventListener('wheel', () => {
            if (isAutoScrolling) {
                isAutoScrolling = false;
                playIcon.style.display = 'block';
                pauseIcon.style.display = 'none';
                updateAutoScroll();
            }
        }, { passive: false });

        // Add gear icon click handler
        document.querySelector('.gear-icon').addEventListener('click', () => {
            document.querySelector('.controls').classList.toggle('collapsed');
        });
    </script>
</body>
</html> 