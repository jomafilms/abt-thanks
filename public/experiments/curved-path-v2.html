<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curved Path V2</title>
    <style>
        body {
            margin: 0;
            background: #111;
            min-height: 100vh;
            overflow: hidden;
        }
        svg {
            width: 100vw;
            height: 100vh;
        }
        .path {
            fill: none;
            stroke: #D4A373;
            stroke-width: 2;
            stroke-linecap: round;
        }
        .dot {
            fill: #D4A373;
            transition: opacity 0.2s ease-out;
        }
    </style>
</head>
<body>
    <svg id="scene">
        <!-- We'll draw a single curved line from bottom to top -->
    </svg>

    <script>
        // Get viewport dimensions
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        // Create the path
        const svg = document.getElementById('scene');
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute('class', 'path');
        svg.appendChild(path);
        
        // Constants for perspective and path
        const HORIZON_Y = height * 0.2;
        const VANISHING_POINT_X = width * 0.5;
        const PATH_BASE_AMPLITUDE = width * 0.2;
        const PERSPECTIVE_FACTOR = 0.8;
        const DOT_SPACING = 0.3;
        const SCROLL_SENSITIVITY = 2.0;

        // Convert world coordinates to screen coordinates with perspective
        function applyPerspective(x, y, t) {
            const scale = 1 / (1 + PERSPECTIVE_FACTOR * t);
            return {
                x: VANISHING_POINT_X + (x - VANISHING_POINT_X) * scale,
                y: HORIZON_Y + (y - HORIZON_Y) * scale
            };
        }

        // Define the curve shape in world coordinates
        function worldCurveAt(t) {
            const baseY = lerp(HORIZON_Y, height, t);
            const amplitude = PATH_BASE_AMPLITUDE * t;
            const x = VANISHING_POINT_X + Math.sin(t * Math.PI * 2) * amplitude;
            return { x, y: baseY };
        }

        // Get screen coordinates for a point on the curve
        function curveAt(t) {
            const worldPos = worldCurveAt(t);
            const perspectiveT = 1 - t;
            return applyPerspective(worldPos.x, worldPos.y, perspectiveT);
        }

        // Update dots based on scroll progress
        function updateDots() {
            // Remove old dots
            const oldDots = svg.querySelectorAll('.dot');
            oldDots.forEach(dot => dot.remove());
            
            // Calculate dot positions
            const numDots = Math.ceil(1.2 / DOT_SPACING);  // Number of dots to show
            for (let i = 0; i < numDots; i++) {
                // Calculate t value for this dot
                let t = (scrollProgress + (i * DOT_SPACING)) % 1.2;
                
                // Only show dots within our view range
                if (t >= 0 && t <= 1.2) {
                    const pos = curveAt(Math.max(0, Math.min(1, t)));
                    const scale = 0.5 + Math.max(0, t);
                    const dotSize = 6 * scale;
                    
                    // Calculate opacity - fade out as t approaches 1
                    const opacity = t >= 0.95 ? (1 - (t - 0.95) / 0.05) : 1;
                    
                    // Create dot
                    const dotElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    dotElement.setAttribute('cx', pos.x);
                    dotElement.setAttribute('cy', pos.y);
                    dotElement.setAttribute('r', dotSize);
                    dotElement.setAttribute('class', 'dot');
                    dotElement.style.opacity = Math.max(0, opacity);
                    
                    svg.appendChild(dotElement);
                }
            }
        }

        // Update path with perspective
        function updatePath() {
            const steps = 100;
            let d = '';
            
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const pos = curveAt(t);
                d += (i === 0 ? 'M' : 'L') + ` ${pos.x},${pos.y}`;
            }
            
            path.setAttribute('d', d);
        }

        // Initialize
        let scrollProgress = 0;
        updatePath();
        updateDots();

        // Scroll handler
        window.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const delta = e.deltaY * SCROLL_SENSITIVITY * 0.001;
            scrollProgress = ((scrollProgress + delta) % 1.2 + 1.2) % 1.2;  // Keep scrollProgress within [0, 1.2]
            
            updateDots();
        }, { passive: false });

        // Helper function for linear interpolation
        function lerp(start, end, t) {
            return start * (1 - t) + end * t;
        }
    </script>
</body>
</html> 